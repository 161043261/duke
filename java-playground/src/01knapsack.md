# 背包问题

01 背包: n 种物品, 每种物品只有 1 个
多重背包: n 种物品, 每种物品有多个
完全背包: n 种物品, 每种物品有 ∞ 个

| 物品 | 数量 n=7 | 重量 w | 收益 v |
| ---- | -------- | ------ | ------ |
| 2    | 1        | 2      | 10     |
| 3    | 1        | 3      | 5      |
| 5    | 1        | 5      | 15     |
| 7    | 1        | 7      | 7      |
| 1    | 1        | 1      | 6      |
| 4    | 1        | 4      | 18     |
| 1    | 1        | 1      | 3      |

背包容量: M=15

背包问题: 下标[0, 6] 的物品, 放入容量为 15 的背包中的最大收益

### 暴力回溯: TODO

### 动态规划

**考虑子问题**

> dp[i][j]: 下标 [0, i] 的物品, 放入容量为 j 的背包的最大收益
> 对 "下标 [0, i] 的物品" 的解释: i+1 个物体不一定全部放入背包, 但背包中物品的最大下标一定是 i

当前的收益, 只取决于是否放入物品 i

```ts
// 物品 i
// 重量 w[i]
// 收益 v[i]
dp[i][j] = // 下标 [0, i] 的物品, 放入容量为 j 的背包的最大收益
    Math.max(
        // 不放物品 i
        // 则 dp[i][j] = 下标 [0, i-1] 的物品, 放入容量为 j 的背包的最大收益
        dp[i - 1][j],
        // 放物品 i
        // 则 dp[i][j] = 下标 [0, i-1] 的物品, 放入容量为 j-w[i] 的背包的最大收益,
        // 再加上 物品 i 的收益
        dp[i - 1][j - w[i]] + v[i]
    );
```

**初始化 dp 数组**

-   只需要初始化第 0 行的所有元素, 和第 0 列的所有元素
-   第 0 行的元素表示下标 [0, 0] 的物品, 放入容量为 j 的背包的最大收益
    => `dp[0][j] = j >= w[0] ? v[0] : 0`
-   第 0 列的元素表示放入容量为 0 的背包 => dp[?][0] 都等于 0
    => `dp[i][0] = 0`

```text
          j-w[i] 列         j 列

i-1 行    dp[i-1][j-w[i]]   dp[i-1][j]

i   行                      dp[i][j]
```

```ts
let rowCount = numGoods;
let columnCount = bagCapacity;

let dp: number[][] = new Array(rowCount)
    .fill([])
    .map(() => new Array(columnCount).fill(0));

for (let j = 0; j < dp[0].length /* bagCapacity */; j++) {
    dp[0][j] = j >= w[0] ? v[0] : 0;
}
```

代码 [01knapsack.ts](./01knapsack.ts)
